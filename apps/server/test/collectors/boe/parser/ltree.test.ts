import { describe, expect, test } from "bun:test";

import fc from "fast-check";

import {
  legalPathAstToLtree,
  legalNodePathToLtree,
  ltreeToLegalPathAst,
  ltreeToLegalNodePath,
  ltreeToNodePathSegments,
  ltreeToNodePath,
  normalizeLegalPathSegment,
  nodePathSegmentsToLtree,
  nodePathToLtree,
  parseLegalPath,
  renderLegalPath,
} from "~/collectors/boe/parser";
import { LegalNodePathString, NodePathString } from "~/collectors/boe/parser/types";

import { parseBoeFragments, readBoeFixture } from "../common";

function createStructuralPathArbitrary() {
  const tagArbitrary = fc.constantFrom("c", "a", "p", "sp", "x", "t", "s", "h");
  const indexArbitrary = fc.integer({ min: 1, max: 2000 });
  return fc
    .array(fc.tuple(tagArbitrary, indexArbitrary), { minLength: 1, maxLength: 12 })
    .map((segments) =>
      NodePathString(`/${segments.map(([tag, index]) => `${tag}/${String(index)}`).join("/")}`),
    );
}

function createLegalPathArbitrary() {
  const segmentArbitrary = fc
    .string({ minLength: 1, maxLength: 20 })
    .filter(
      (value) =>
        !value.includes("/") &&
        value.trim().length > 0 &&
        normalizeLegalPathSegment(value).length > 0,
    );
  return fc
    .array(segmentArbitrary, { minLength: 1, maxLength: 10 })
    .map((segments) => LegalNodePathString(`/${segments.join("/")}`));
}

describe("ltree path compatibility", () => {
  test("round-trips structural parser nodePath without loss", () => {
    const source = NodePathString("/c/22/a/3/p/1/sp/4");
    const encoded = nodePathToLtree(source);
    const decoded = ltreeToNodePath(encoded);

    expect(String(decoded)).toBe(String(source));
    expect(String(encoded)).toBe("n_c_22.n_a_3.n_p_1.n_sp_4");
  });

  test("round-trips legal parser path without loss", () => {
    const source = LegalNodePathString("/disposicion-final/article/primera/p/1");
    const encoded = legalNodePathToLtree(source);
    const decoded = ltreeToLegalNodePath(encoded);

    expect(String(decoded)).toBe(String(source));
  });

  test("is fully compatible with structural paths generated by parser fixtures", async () => {
    const xml = await readBoeFixture("real-boe-full.xml");
    const fragments = await parseBoeFragments(xml);

    for (const fragment of fragments) {
      const encoded = nodePathToLtree(fragment.nodePath);
      const decoded = ltreeToNodePath(encoded);
      expect(String(decoded)).toBe(String(fragment.nodePath));
    }
  });

  test("is fully compatible with legal paths generated by parser fixtures", async () => {
    const xml = await readBoeFixture("constitution-1978.xml");
    const fragments = await parseBoeFragments(xml);

    for (const fragment of fragments) {
      if (fragment.legalNodePath === undefined) {
        continue;
      }

      const encoded = legalNodePathToLtree(fragment.legalNodePath);
      const decoded = ltreeToLegalNodePath(encoded);
      expect(String(decoded)).toBe(String(fragment.legalNodePath));
    }
  });

  test("rejects structural decode if ltree payload is not a structural path", () => {
    const encoded = legalNodePathToLtree(LegalNodePathString("/article/38"));
    expect(() => ltreeToNodePath(encoded)).toThrow("Unsupported structural ltree label");
  });

  test("round-trips structural AST path segments", () => {
    const source = NodePathString("/c/2/a/1/p/3");
    const encoded = nodePathSegmentsToLtree(ltreeToNodePathSegments(nodePathToLtree(source)));
    const decoded = ltreeToNodePath(encoded);

    expect(String(decoded)).toBe(String(source));
  });

  test("round-trips legal AST path segments", () => {
    const source = parseLegalPath("/disposicion-final/article/primera/p/1");
    const encoded = legalPathAstToLtree(source);
    const decoded = ltreeToLegalPathAst(encoded);

    expect(decoded).toEqual(source);
  });

  test("fuzz: structural paths round-trip deterministically", () => {
    const structuralPathArbitrary = createStructuralPathArbitrary();
    fc.assert(
      fc.property(structuralPathArbitrary, (source) => {
        const encoded = nodePathToLtree(source);
        const decoded = ltreeToNodePath(encoded);
        expect(String(decoded)).toBe(String(source));
      }),
      {
        seed: 2444615283,
        numRuns: 800,
      },
    );
  });

  test("fuzz: legal paths round-trip deterministically", () => {
    const legalPathArbitrary = createLegalPathArbitrary();
    fc.assert(
      fc.property(legalPathArbitrary, (source) => {
        const encoded = legalNodePathToLtree(source);
        const decoded = ltreeToLegalNodePath(encoded);
        const canonical = renderLegalPath(parseLegalPath(source));
        expect(String(decoded)).toBe(String(canonical));
      }),
      {
        seed: 2444615283,
        numRuns: 800,
      },
    );
  });
});
